String对象是不可变的。效率低
重载的意思是一个操作符在应用于特定的类时，被赋予了特殊的意义（+，+=）
如果你要在toString（）方法中使用循环，那么最好创建一个Stringbulider对象。
当你创建一个Formatter对象的时候需要告诉它结果向哪里输出。




元字符	描述
\	将下一个字符标记符、或一个向后引用、或一个八进制转义符。相当于多种编程语言中都有的“转义字符”的概念。
^	匹配输入字符串的开始位置。
$	匹配输入字符串的结束位置。
*	匹配前面的子表达式零次或多次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。
+	匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。
?	匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。
{n}	n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。
{n,}	n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。
{n,m}	m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。请注意在逗号和两个数之间不能有空格。
.	匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。
(x)	捕获组。可以在正则表达式中使用\i引用第i个捕获组
x|y	匹配x或y。例如，“z|food”能匹配“z”或“food”。“[z|f]ood”则匹配“zood”或“food”或”|ood”。
[xyz]	字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。
[^xyz]	负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。
[a-z]	字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。
[^a-z]	负值字符范围。匹配任何不在指定范围内的任意字符。“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。
\b	匹配一个单词边界，单词和空格间的位置。“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。
\B	匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。
\cx	匹配由x指明的控制字符。\cM匹配Ctrl-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。
\d	匹配一个数字字符。等价于[0-9]。
\D	匹配一个非数字字符。等价于[^0-9]。
\f	匹配一个换页符。等价于\x0c和\cL。
\n	匹配一个换行符。等价于\x0a和\cJ。
\r	匹配一个回车符。等价于\x0d和\cM。
\s	匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。
\S	匹配任何可见字符。等价于[^ \f\n\r\t\v]。
\t	匹配一个制表符。等价于\x09和\cI。
\v	匹配一个垂直制表符。等价于\x0b和\cK。
\w	匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。
\W	匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
\xn	匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&1”。正则表达式中可以使用ASCII编码。
\num	匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。
以上是常用的元字符，还有很多复用的技巧，比如[a-zA-Z]可以匹配一个无论大小写的字符，[a-z&&[jhk]]可以匹配j、h或k。

3.贪婪型、勉强型与占有型

在java中我们把？（一个或零个）、*（零个或多个）、+（一个或多个）、{n}、{n，m}、{n，}统称为正则表达式的量词。量词描述了一个模式吸收输入文本的方式，那么这些量词又有很多种状态，比如贪婪型、勉强型（懒惰型、非贪婪型）和java独有的占有型（完美型）。
贪婪型匹配： 
默认情况下为贪婪型匹配。量词总是贪婪的，除非有其他的选项被设置。贪婪型表达式会为所有的模式发现尽可能多的匹配。如果贪婪型匹配模式已经发现了一个符合条件的字符串，他会继续向下探测可不可能继续匹配字符串。 
贪婪型： X? X* X+ 
勉强型匹配： 
在量词的尾部添加“？”表示量词匹配为勉强型匹配。勉强型匹配会匹配可以满足条件的尽可能少的字符数。 
勉强型： X?? X*? X+? 
占有型匹配（java可用）： 
占有型匹配仅仅在java中可以使用。在整个表达式的尾部添加“+”表示量词匹配为占有型匹配。它很类似贪婪型，但是不同的是，贪婪型在尽可能多的去匹配，但是发现不成功时会回退，去保证匹配一个可以匹配的字符串，而占有性不会回退。 
占有型： X?+ X*+ X++

Pattern标记    括号内的表示嵌入表达式
Pattern Pattern.compile(String regex,int flag)，其中的flag来自以下Pattern类中的常量：
Pattern.CASE_INSENSITIVE(?i)  这个标记允许模式不必考虑大小写
Pattern.COMMENTS(?x) 在这种模式下，空格符将被忽略掉，并且以#开始直到行末的注释也会被忽略掉
Pattern.DOTALL(?s) 在dotall模式中，表达式"."匹配所有字符，包括行终结符。默认情况下，“.”表达式不匹配行终结符。
Pattern.MULTILINE(?m) 在多行模式下，表达式^和$分别匹配一行的开始和结束。^还匹配输入字符串的开始，$还匹配输入字符串的结尾。默认情况下，这些表达式仅匹配输入的完整字符串的开始和结束。
Pattern.UNICODE_CASE(?u) 指定这个标记，并且开启CASE_INSENSITIVE时，大小写不敏感的匹配将按照与Unicode标准相一致的方式进行。
Pattern.UNIX_LINES(?d)  在这种模式下，在 . 、^ $ 行为中，只识别终结字符 \n  
Pattern p = Pattern.compile("^java", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);

